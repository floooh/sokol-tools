/*
    Generate sokol-nim module.
*/
#include "shdc.h"
#include "fmt/format.h"
#include "pystring.h"
#include <stdio.h>

namespace shdc {

using namespace util;

static std::string file_content;

#if defined(_MSC_VER)
#define L(str, ...) file_content.append(fmt::format(str, __VA_ARGS__))
#else
#define L(str, ...) file_content.append(fmt::format(str, ##__VA_ARGS__))
#endif

static const char* uniform_type_to_sokol_type_str(uniform_t::type_t type) {
    switch (type) {
        case uniform_t::FLOAT:  return "sg.UniformType.mat4";
        case uniform_t::FLOAT2: return "sg.UniformType.float2";
        case uniform_t::FLOAT3: return "sg.UniformType.float3";
        case uniform_t::FLOAT4: return "sg.UniformType.float4";
        case uniform_t::INT:    return "sg.UniformType.int";
        case uniform_t::INT2:   return "sg.UniformType.int2";
        case uniform_t::INT3:   return "sg.UniformType.int3";
        case uniform_t::INT4:   return "sg.UniformType.int4";
        case uniform_t::MAT4:   return "sg.UniformType.mat4";
        default: return "FIXME";
    }
}

static const char* uniform_type_to_flattened_sokol_type_str(uniform_t::type_t type) {
    switch (type) {
        case uniform_t::FLOAT:
        case uniform_t::FLOAT2:
        case uniform_t::FLOAT3:
        case uniform_t::FLOAT4:
        case uniform_t::MAT4:
             return "sg.UniformType.float4";
        case uniform_t::INT:
        case uniform_t::INT2:
        case uniform_t::INT3:
        case uniform_t::INT4:
            return "sg.UniformType.int4";
        default: return "FIXME";
    }
}

static const char* img_type_to_sokol_type_str(image_t::type_t type) {
    switch (type) {
        case image_t::IMAGE_TYPE_2D:    return "sg.ImageType.twoDee";
        case image_t::IMAGE_TYPE_CUBE:  return "sg.ImageType.cube";
        case image_t::IMAGE_TYPE_3D:    return "sg.ImageType.threeDee";
        case image_t::IMAGE_TYPE_ARRAY: return "sg.ImageType.array";
        default: return "INVALID";
    }
}

static const char* img_basetype_to_sokol_samplertype_str(image_t::basetype_t basetype) {
    switch (basetype) {
        case image_t::IMAGE_BASETYPE_FLOAT: return "sg.SamplerType.float";
        case image_t::IMAGE_BASETYPE_SINT:  return "sg.SamplerType.sint";
        case image_t::IMAGE_BASETYPE_UINT:  return "sg.SamplerType.uint";
        default: return "INVALID";
    }
}

static const char* sokol_backend(slang_t::type_t slang) {
    switch (slang) {
        case slang_t::GLSL330:      return "sg.Backend.glcore33";
        case slang_t::GLSL100:      return "sg.Backend.gles2";
        case slang_t::GLSL300ES:    return "sg.Backend.gles2";
        case slang_t::HLSL4:        return "sg.Backend.d3d11";
        case slang_t::HLSL5:        return "sg.Backend.d3d11";
        case slang_t::METAL_MACOS:  return "sg.Backend.metalMacos";
        case slang_t::METAL_IOS:    return "sg.Backend.metalIos";
        case slang_t::METAL_SIM:    return "sg.Backend.metalSimulator";
        case slang_t::WGPU:         return "sg.Backend.wgpu";
        default: return "<INVALID>";
    }
}

static void write_header(const args_t& args, const input_t& inp, const spirvcross_t& spirvcross) {
    L("#\n");
    L("#  #version:{}# (machine generated, don't edit!)\n", args.gen_version);
    L("#\n");
    L("#  Generated by sokol-shdc (https://github.com/floooh/sokol-tools)\n");
    L("#\n");
    L("#  Cmdline: {}\n", args.cmdline);
    L("#\n");
    L("#  Overview:\n");
    L("#\n");
    for (const auto& item: inp.programs) {
        const program_t& prog = item.second;

        const spirvcross_source_t* vs_src = find_spirvcross_source_by_shader_name(prog.vs_name, inp, spirvcross);
        const spirvcross_source_t* fs_src = find_spirvcross_source_by_shader_name(prog.fs_name, inp, spirvcross);
        assert(vs_src && fs_src);
        L("#       Shader program '{}':\n", prog.name);
        L("#           Get shader desc: shd.{}ShaderDesc(sg.queryBackend())\n", to_camel_case(fmt::format("{}_{}", mod_prefix(inp), prog.name)));
        L("#           Vertex shader: {}\n", prog.vs_name);
        L("#               Attribute slots:\n");
        const snippet_t& vs_snippet = inp.snippets[vs_src->snippet_index];
        for (const attr_t& attr: vs_src->refl.inputs) {
            if (attr.slot >= 0) {
                L("#                   ATTR_{}{}_{} = {}\n", mod_prefix(inp), vs_snippet.name, attr.name, attr.slot);
            }
        }
        for (const uniform_block_t& ub: vs_src->refl.uniform_blocks) {
            L("#               Uniform block '{}':\n", ub.struct_name);
            L("#                   C struct: {}{}_t\n", mod_prefix(inp), ub.struct_name);
            L("#                   Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), ub.struct_name, ub.slot);
        }
        for (const image_t& img: vs_src->refl.images) {
            L("#               Image '{}':\n", img.name);
            L("#                   Type: {}\n", img_type_to_sokol_type_str(img.type));
            L("#                   Component Type: {}\n", img_basetype_to_sokol_samplertype_str(img.base_type));
            L("#                   Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), img.name, img.slot);
        }
        L("#           Fragment shader: {}\n", prog.fs_name);
        for (const uniform_block_t& ub: fs_src->refl.uniform_blocks) {
            L("#               Uniform block '{}':\n", ub.struct_name);
            L("#                   C struct: {}{}_t\n", mod_prefix(inp), ub.struct_name);
            L("#                   Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), ub.struct_name, ub.slot);
        }
        for (const image_t& img: fs_src->refl.images) {
            L("#               Image '{}':\n", img.name);
            L("#                   Type: {}\n", img_type_to_sokol_type_str(img.type));
            L("#                   Component Type: {}\n", img_basetype_to_sokol_samplertype_str(img.base_type));
            L("#                   Bind slot: SLOT_{}{} = {}\n", mod_prefix(inp), img.name, img.slot);
        }
        L("#\n");
    }
    L("#\n");
    L("import sokol/gfx as sg\n");    
    for (const auto& cimport: inp.cimports) {
        L("{}\n", cimport);
    }
    L("\n");
}

static void write_vertex_attrs(const input_t& inp, const spirvcross_t& spirvcross) {
    for (const spirvcross_source_t& src: spirvcross.sources) {
        if (src.refl.stage == stage_t::VS) {
            const snippet_t& vs_snippet = inp.snippets[src.snippet_index];
            for (const attr_t& attr: src.refl.inputs) {
                if (attr.slot >= 0) {
                    const auto attrName = to_camel_case(fmt::format("ATTR_{}_{}_{}", mod_prefix(inp), vs_snippet.name, attr.name));
                    L("const {}* = {}\n", attrName, attr.slot);
                }
            }
        }
    }
    L("\n");
}

static void write_image_bind_slots(const input_t& inp, const spirvcross_t& spirvcross) {
    for (const image_t& img: spirvcross.unique_images) {
        const auto slotName = to_camel_case(fmt::format("SLOT_{}_{}", mod_prefix(inp), img.name));
        L("const {}* = {}\n", slotName, img.slot);
    }
    L("\n");
}

static void write_uniform_blocks(const input_t& inp, const spirvcross_t& spirvcross, slang_t::type_t slang) {
    for (const uniform_block_t& ub: spirvcross.unique_uniform_blocks) {
        const auto slotName = to_camel_case(fmt::format("SLOT_{}_{}", mod_prefix(inp), ub.struct_name));
        L("const {}* = {}\n", slotName, ub.slot);
        L("type {}* {{.packed.}} = object\n", to_pascal_case(fmt::format("{}_{}", mod_prefix(inp), ub.struct_name)));
        int cur_offset = 0;
        for (const uniform_t& uniform: ub.uniforms) {
            // align the first item
            int next_offset = uniform.offset;
            if (next_offset > cur_offset) {
                L("    pad_{}: array[{}, uint8]\n", cur_offset, next_offset - cur_offset);
                cur_offset = next_offset;
            }
            const char* align = (0 == cur_offset) ? " {.align(16).}" : "";
            if (inp.ctype_map.count(uniform_type_str(uniform.type)) > 0) {
                // user-provided type names
                if (uniform.array_count == 1) {
                    L("    {}*{}: {}\n", uniform.name, align, inp.ctype_map.at(uniform_type_str(uniform.type)));
                }
                else {
                    L("    {}*{}: [{}]{}\n", uniform.name, align, uniform.array_count, inp.ctype_map.at(uniform_type_str(uniform.type)));
                }
            }
            else {
                // default type names (float)
                if (uniform.array_count == 1) {
                    switch (uniform.type) {
                        case uniform_t::FLOAT:   L("    {}*{}: float32\n", uniform.name, align); break;
                        case uniform_t::FLOAT2:  L("    {}*{}: array[2, float32]\n", uniform.name, align); break;
                        case uniform_t::FLOAT3:  L("    {}*{}: array[3, float32]\n", uniform.name, align); break;
                        case uniform_t::FLOAT4:  L("    {}*{}: array[4, float32]\n", uniform.name, align); break;
                        case uniform_t::INT:     L("    {}*{}: int32\n", uniform.name, align); break;
                        case uniform_t::INT2:    L("    {}*{}: array[2, int32]\n", uniform.name, align); break;
                        case uniform_t::INT3:    L("    {}*{}: array[3, int32]\n", uniform.name, align); break;
                        case uniform_t::INT4:    L("    {}*{}: array[4, int32]\n", uniform.name, align); break;
                        case uniform_t::MAT4:    L("    {}*{}: array[16, float32]\n", uniform.name, align); break;
                        default:                 L("    INVALID_UNIFORM_TYPE\n"); break;
                    }
                }
                else {
                    switch (uniform.type) {
                        case uniform_t::FLOAT4:  L("    {}*{}: array[{}, array[4, float32]]\n", uniform.name, align, uniform.array_count); break;
                        case uniform_t::INT4:    L("    {}*{}: array[{}, array[4, int32]]\n", uniform.name, align, uniform.array_count); break;
                        case uniform_t::MAT4:    L("    {}*{}: array[{}, array[16, float32]]\n", uniform.name, align, uniform.array_count); break;
                        default:                 L("    INVALID_UNIFORM_TYPE\n"); break;
                    }
                }
            }
            cur_offset += uniform_size(uniform.type, uniform.array_count);
        }
        /* pad to multiple of 16-bytes struct size */
        const int round16 = roundup(cur_offset, 16);
        if (cur_offset != round16) {
            L("    pad_{}: array[{}, uint8]\n", cur_offset, round16-cur_offset);
        }
        L("\n");
    }
}

errmsg_t sokolnim_t::gen(const args_t& args, const input_t& inp,
                     const std::array<spirvcross_t,slang_t::NUM>& spirvcross,
                     const std::array<bytecode_t,slang_t::NUM>& bytecode)
{
    // first write everything into a string, and only when no errors occur,
    // dump this into a file (so we don't have half-written files lying around)
    file_content.clear();

    bool comment_header_written = false;
    bool common_decls_written = false;
    for (int i = 0; i < slang_t::NUM; i++) {
        slang_t::type_t slang = (slang_t::type_t) i;
        if (args.slang & slang_t::bit(slang)) {
            errmsg_t err = check_errors(inp, spirvcross[i], slang);
            if (err.valid) {
                return err;
            }
            if (!comment_header_written) {
                write_header(args, inp, spirvcross[i]);
                comment_header_written = true;
            }
            if (!common_decls_written) {
                common_decls_written = true;
                write_vertex_attrs(inp, spirvcross[i]);
                write_image_bind_slots(inp, spirvcross[i]);
                write_uniform_blocks(inp, spirvcross[i], slang);
            }
            //write_shader_sources_and_blobs(inp, spirvcross[i], bytecode[i], slang);
        }
    }

    // write access functions which return sg.ShaderDesc structs
/*
    for (const auto& item: inp.programs) {
        const program_t& prog = item.second;
        L("pub fn {}ShaderDesc(backend: sg.Backend) sg.ShaderDesc {{\n", to_camel_case(fmt::format("{}_{}", mod_prefix(inp), prog.name)));
        L("    var desc: sg.ShaderDesc = .{{}};\n");
        L("    switch (backend) {{\n");
        for (int i = 0; i < slang_t::NUM; i++) {
            slang_t::type_t slang = (slang_t::type_t) i;
            if (args.slang & slang_t::bit(slang)) {
                L("        {} => {{\n", sokol_backend(slang));
                write_shader_desc_init("            ", prog, inp, spirvcross[i], bytecode[i], slang);
                L("        }},\n");
            }
        }
        L("        else => {{}},\n");
        L("    }}\n");
        L("    return desc;\n");
        L("}}\n");
    }
*/

    // write result into output file
    FILE* f = fopen(args.output.c_str(), "w");
    if (!f) {
        return errmsg_t::error(inp.base_path, 0, fmt::format("failed to open output file '{}'", args.output));
    }
    fwrite(file_content.c_str(), file_content.length(), 1, f);
    fclose(f);
    return errmsg_t();
}

} // namespace shdc
