/*
    Compile HLSL / Metal source code to bytecode, HLSL only works
    when running on Windos, Metal only works when running on macOS.

    Uses d3dcompiler.dll for HLSL, and for Metal, invokes the Metal
    compiler toolchain commandline tools.
*/
#include "shdc.h"
#include "fmt/format.h"
#include <stdio.h> // popen etc...

namespace shdc {

// write source code to file
static bool write_source(const std::string& source_code, const std::string path) {
    FILE* f = fopen(path.c_str(), "wb");
    if (f) {
        fwrite(source_code.c_str(), source_code.length(), 1, f);
        fclose(f);
        return true;
    }
    else {
        return false;
    }
}

// MacOS/Metal specific stuff...
#if defined(__APPLE__)
// run a command line program via xcrun, capture its output and exit code
static int runcmd(const std::string& cmdline, std::string& output, slang_t::type_t slang) {
    std::string cmd = "xcrun ";
    if (slang == slang_t::METAL_MACOS) {
        cmd += "--sdk macosx ";
    }
    else {
        cmd += "--sdk iphoneos ";
    }
    cmd += cmdline;
    cmd += " 2>&1";

    int exit_code = 10;
    FILE* p = popen(cmd.c_str(), "r");
    if (p) {
        char buf[1024];
        buf[0] = 0;
        while (fgets(buf, sizeof(buf), p)) {
            output += buf;
        }
        exit_code = pclose(p);
    }
    return exit_code;
}

// run the metal compiler pass
static int cc(const std::string& src_path, const std::string& out_dia, const std::string& out_air, slang_t::type_t slang, std::string& output) {
    std::string cmdline;
    cmdline =  "metal -arch air64 -emit-llvm -ffast-math -c -serialize-diagnostics ";
    cmdline += out_dia;
    cmdline += " -o ";
    cmdline += out_air;
    if (slang == slang_t::METAL_IOS) {
        cmdline += " -miphoneos-version-min=9.0 -std=ios-metal1.0 ";
    }
    else {
        cmdline += " -mmacosx-version-min=10.11 -std=osx-metal1.1 ";
    }
    cmdline += src_path;
    return runcmd(cmdline, output, slang);
}

static bytecode_t compile_metal(const args_t& args, const input_t& inp, const spirvcross_t& spirvcross, slang_t::type_t slang) {
    bytecode_t bytecode;
    std::string base_path = fmt::format("{}{}_{}_", args.tmpdir, inp.filename, slang_t::to_str(slang)); 
    std::string src_path, dia_path, air_path;

    // for each vertex/fragment shader source generated by SPIRV-Cross:
    std::string output;
    int res = 0;
    for (const spirvcross_source_t& src: spirvcross.sources) {
        const snippet_t& snippet = inp.snippets[src.snippet_index];
        src_path = fmt::format("{}{}.metal", base_path, snippet.name);
        dia_path = fmt::format("{}{}.dia", base_path, snippet.name);
        air_path = fmt::format("{}{}.air", base_path, snippet.name);
        // write metal source code to temp file
        if (!write_source(src.source_code, src_path)) {
            bytecode.errors.push_back(errmsg_t(inp.path, 0, fmt::format("failed to write intermediate file '{}'!", src_path)));
            break;
        }
        // run the compiler pass
        res = cc(src_path, dia_path, air_path, slang, output);
        if (0 != res) {
            break;
        }
    }
    // translate errors?
    if (0 != res) {
        // FIXME: translate error messages
    }
    return bytecode;
}
#endif

bytecode_t bytecode_t::compile(const args_t& args, const input_t& inp, const spirvcross_t& spirvcross, slang_t::type_t slang) {
    bytecode_t bytecode;
    #if defined(__APPLE__)
    if ((slang == slang_t::METAL_MACOS) || (slang == slang_t::METAL_IOS)) {
        bytecode = compile_metal(args, inp, spirvcross, slang);
    }
    #endif
    return bytecode;
}

void bytecode_t::dump_debug() const {
    fmt::print(stderr, "bytecode_t::dump_debug(): FIXME!\n");
}

} // namespace shdc

